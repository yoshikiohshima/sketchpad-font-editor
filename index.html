<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"> 
  </head>
  <body>
   <div id="renkon">
      <script type="reactive">
          const preactModule = import('./preact.standalone.module.js');
          const html = preactModule.html;
          const render = preactModule.render;

          const lineButton = Events.click("#line");
          const arcButton = Events.click("#arc");
          const deleteButton = Events.click("#delete");
          const charClick = Events.click("#chars");

          const toolState = Behaviors.collect(
              "line",
              Events.or(lineButton, arcButton, deleteButton),
              (_old, evt) => evt.target.id
          );

          // toolHighlighter
          ((toolState) => {
              for (const child of [...document.querySelector("#tools").childNodes]) {
                  if (child.setAttribute) {
                      child.setAttribute("toolSelected", child.id === toolState ? "true" : "false");
                  }
              }
          })(toolState);

          console.log(toolState);

          const selectedChar = Events.collect(" ", charClick, (old, evt) => {
              const id = evt.target.id;
              const match = /([0-9]+)/.exec(id);
              const n = parseFloat(match[1]);
              return String.fromCharCode(n);
          });

          const gridSpec = {width: 384, height: 512, x: 10, y: 16};

          const coordinateMap = (evt) => {
              const rect = evt.target.getBoundingClientRect();
              return {
                  x: Math.floor(evt.x - rect.x) - 40,
                  y: gridSpec.height - Math.floor(evt.y - rect.top - 40)
              }
          };
          const griddedMap = (evt) => {
              const rect = evt.target.getBoundingClientRect();
	      const gridX = gridSpec.width / gridSpec.x;
	      const gridY = gridSpec.height / gridSpec.y;
              const x = Math.max(0, Math.round((evt.clientX - rect.x - (gridX/2)) / gridX));
              const y = gridSpec.y - 1 - Math.round((evt.clientY - rect.y - (gridY / 2)) / gridY);
              return {x, y, target: evt.target};
          };

          const griddedUnmap = (p, useRect) => {
	      const gridX = gridSpec.width / gridSpec.x;
	      const gridY = gridSpec.height / gridSpec.y;
	      let offset;
	      if (useRect) {
		  const rect = p.target.getBoundingClientRect();
		  offset = {x: rect.x, y: rect.y};
	      } else {
		  offset = {x: 0, y: 0};
	      }
	      return {
		  x: p.x * gridX + (gridX/2) + offset.x,
		  y: (gridSpec.y - p.y - 1) * gridY + (gridY/2) + offset.y
	      }
          };

          const interactionBuffer = Events.collect({command: "line", points: [], state: null}, Events.or(editorDown, Events.change(toolState)), (points, evt) => {
              if (typeof evt === "string") {
                  return {command: evt, points: [], state: null};
              }
              const p = griddedMap(evt);
              const newPoints = [...points.points, p];
              if (points.command === "line") {
                  if (points.points.length === 0) {
                      return {command: "line", points: newPoints, state: null};
                  }
                  if (points.points.length === 1) {
                      return {command: "line", points: [], state: newPoints};
                  }
              } else if (points.command === "arc") {
                  if (points.points.length === 0 || points.points.length === 1) {
                      return {command: "arc", points: newPoints, state: null};
                  }
                  if (points.points.length === 2) {
                      return {command: "arc", points: [], state: newPoints};
                  }
              } else if (points.command === "delete") {
                  return {command: "delete", points: [], state: newPoints};
              }
          });

          const hit = (seg, p) => {
              if (seg.command === "line") {
                  const ps = seg.state;
                  const p1 = ps[0];
                  const p2 = ps[1];
                  const dist = Math.abs(
                      (p2.y - p1.y) * p.x -
                      (p2.x - p1.x) * p.y +
                      p2.x * p1.y -
                      p2.y * p1.x)
                      /
                      Math.sqrt((p2.y - p1.y) ** 2 + (p2.x - p1.x) ** 2);
                  const xIn = p1.x >= p2.x ?
                        p.x >= p2.x - 4 && p1.x + 4 > p.x :
                        p.x >= p1.x - 4 && p2.x + 4 > p.x;
                  const yIn = p1.y >= p2.y ?
                        p.y >= p2.y - 4 && p1.y + 4 > p.y :
                        p.y >= p1.y - 4 && p2.y + 4 > p.y;
                  return xIn && yIn && dist < 4;
              }
              return false;
          };

          const segments = Behaviors.collect([], interactionBuffer, (segs, buffer) => {
              if (!buffer.state) {return segs;}
              if (buffer.command === "delete") {
                  const p = buffer.state[0];
                  const found = false;
                  for (let index = segs.length - 1; index >= 0; index--) {
                      const seg = segs[index];
                      if (hit(seg, p)) {
                          const result = [...segs];
                          result.splice(index, 1);
                          return result;
                      }
                  }
                  return segs;
              }
              return [...segs, buffer];
          });

          const makeLine = (p1, p2, html) => {
              return html`<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="#ddd" stroke-width="4"></line>`;
          };

          const makeArc = (p1, p2, p3, html) => {
              const r = Math.sqrt((p1.x - p3.x) ** 2 + (p1.y - p3.y) ** 2);
              return html`<path d="M ${p1.x} ${p1.y} A ${r} ${r} 0 0 0 ${p2.x} ${p2.y}" stroke="#ddd" stroke-width="4" fill="transparent"></path>`;
          };

          const lines = segments.map((seg) => {
              if (seg.command === "line") {
                  const ps = seg.state;
                  const p1 = griddedUnmap(ps[0]);
                  const p2 = griddedUnmap(ps[1]);
                  return makeLine(p1, p2, html);
              }
              if (seg.command === "arc") {
                  const ps = seg.state;
                  const c = griddedUnmap(ps[0]);
                  const p1 = griddedUnmap(ps[1]);
                  const p2 = griddedUnmap(ps[2]);
                  return makeArc(c, p1, p2, html);
              }
          });

          const linesSVG = html`<svg viewBox="0 0 ${gridSpec.width} ${gridSpec.height}" xmlns="http://www.w3.org/2000/svg">${[...lines, rubberBandLine]}</svg>`;

          render(linesSVG, document.querySelector("#editorPane2"));

          const editorDown = Events.listener("#editorPane", "pointerdown", (evt) => evt);
          const editorMove = Events.listener("#editorPane", "pointermove", (evt) => evt);

          const gridMover = ((editorMove) => {
              const p = griddedUnmap(griddedMap(editorMove), true);
              const gridCursor = document.querySelector("#gridCursor");
              gridCursor.style.left = `${p.x - 5}px`;
              gridCursor.style.top = `${p.y - 5}px`;
          })(editorMove);

          const rubberBandUpdate = ((interactionBuffer, editorMove, html) => {
              const points = interactionBuffer.points;
              if (interactionBuffer.command === "line") {
                  if (points.length === 1) {
                      const p1 = griddedUnmap(points[0]);
                      const p2 = griddedUnmap(griddedMap(editorMove));
                      return makeLine(p1, p2, html);
                  }
              } else if (interactionBuffer.command === "arc") {
                  if (points.length === 1) {
                      const p1 = griddedUnmap(points[0]);
                      const p2 = griddedUnmap(griddedMap(editorMove));
                      return makeLine(p1, p2, html);
                  } else if (points.length === 2) {
                      const p1 = griddedUnmap(points[0]);
                      const p2 = griddedUnmap(points[1]);
                      const p3 = griddedUnmap(griddedMap(editorMove));
		      return makeArc(p1, p2, p3, html);
		  }
	      }

              return makeLine({x: 0, y: 0}, {x: 0, y: 0}, html);
          })(Behaviors.keep(interactionBuffer), editorMove, html);

          const rubberBandLine = Behaviors.collect(
              makeLine({x: 0, y: 0}, {x: 0, y: 0}, html),
              rubberBandUpdate,
              (_old, r) => r);

          const charEntry = (i, html) => {
              const c = String.fromCharCode(i);
              return html`<div class="charHolder" id="holder-${i}"><div class="charName">${c}</div><div class="charView"></div></div>`;
          }

          const charList = ((html, charEntry) => [...Array(96).keys()].map((i) => charEntry(i + 32, html)))(html, charEntry);

          const charsHTML = html`<div class="charViews">${charList}</div>`;

          render(charsHTML, document.querySelector("#chars"));

          function makeGridCanvas(options) {
              const {width, height, x, y, radius, canvas} = options;
              const cellW = width / x;
              const cellH = height / y;

              const r = radius || 2;

              // each cell is in the size of (cellW, cellH)
              // the center of the dot is ((cellW/2) + i * cellW, (cellH/2) + j * cellH)
              // where i is [0..x] and j is [0..y]

              const myCanvas = canvas || document.createElement("canvas");
              myCanvas.width = width;
              myCanvas.height = height;
              const ctx = myCanvas.getContext("2d");
    
              ctx.clearRect(0, 0, width, height);
              ctx.fillStyle = "#bbb";

              for (let j = 0; j < y; j++) {
                  for (let i = 0; i < x; i++) {
                      ctx.beginPath();
                      ctx.ellipse((cellW/2) + i * cellW, (cellH/2) + j * cellH, r, r, 0, 0, Math.PI * 2);
                      ctx.fill();
                  }
              }
              return myCanvas;
          }

          const gridCanvas = makeGridCanvas({...gridSpec, canvas: document.querySelector("#gridCanvas")});

          console.log(selectedChar);
      </script>
      <div id="all">
        <div id="charEditor">
          <div id="tools">
            <div id="line" class="toolButton">Line</div>
            <div id="arc" class="toolButton">Arc</div>
            <div id="delete" class="toolButton">Delete</div>
          </div>
          <div id="editorPaneHolder">
	      <div class="zeroHeight">
		  <canvas id="gridCanvas"></canvas>
	      </div>
	      <div class="zeroHeight">
		  <div id="editorPane"></div>
	      </div>
	      <div class="zeroHeight">
		  <div id="editorPane2"></div>
	      </div>
            <div id="gridCursor"></div>
          </div>
        </div>
        <div id="chars"></div>
      </div>
      <style>
        #all {
            display: grid;
            height: 100%;
        }

        #charEditor {
            background-color: white;
            display: flex;
        }

        #tools {
            background-color: #888;
            width: 64px;
            height: 592px;
            display: flex;
            flex-direction: column;
        }

        .charHolder {
            display: flex;
            flex-direction: column;
        }

        .charName {
            color: black;
            height: 16px;
            pointer-events: none;
        }

        .charView {
            width: 60px;
            height: 60px;
            border: 1px ridge rgba(211, 220, 220, .6);
            background-color: #510;
            pointer-events: none;
        }
        
        .toolButton {
            font-size: 18px;
            width: 56px;
            height: 56px;
            color: #eee;
            text-align: center;
            border: 4px solid #888;
        }

        .toolButton[toolSelected="true"] {
            background-color: #ccc;
            border: 2px ridge rgba(120, 120, 120, .6);
            border-radius: 4px;
        }

        #editorPaneHolder {
            height: 592px;
            box-sizing: border-box;
	    display: flex;
	    flex-direction: column;
        }

	.zeroHeight {
	    height: 0px;
	}

        #editorPane {
            background-color: transparent;
            width: calc(384px);
            height: calc(512px);
	    margin: 40px;
        }

        #editorPane2 {
            box-sizing: border-box;
            background-color: transparent;
            width: calc(384px + 40px + 40px);
            height: calc(512px + 40px + 40px);
            border: 40px ridge rgba(211, 220, 220, .6);
            pointer-events: none;
        }

        #gridCanvas {
            box-sizing: border-box;
            background-color: #222;
            width: calc(384px + 40px + 40px);
            height: calc(512px + 40px + 40px);
            border: 40px ridge rgba(211, 220, 220, .6);
            pointer-events: none;
        }

        #chars {
            margin-top: 20px;
            background-color: #ccc;
        }

        .charViews {
            display: flex;
            flex-wrap: wrap;
        }

        #gridCursor {
            width: 10px;
            height: 10px;
            background-color: #bbb;
            position: absolute;
            pointer-events: none;
            transition: top 0.2s;
            transition: left 0.2s;
        }
      </style>
   </div>
   <script type="module">
     import {view} from "./dist/renkon.js";
     view();
    </script>
  </body>
</html>
